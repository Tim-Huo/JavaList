### 简介：

JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突），当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间。

HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。

所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法可以减少碰撞。

### 拉链法：

所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。

当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。

![图片](https://uploader.shimo.im/f/u1zt1iAu9mwQJHNO.png!thumbnail)

### put方法：

HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。

对putVal方法添加元素的分析如下：

* ①如果定位到的数组位置没有元素 就直接插入。
* ②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就放在后面的链表里，链表长度大于8，就转红黑树

![图片](https://uploader.shimo.im/f/3pfwNbfyIMoPW1Tp.png!thumbnail)

### 扩容：

| 参数   | 含义   | 
|:----|:----|
| capacity   | table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。   | 
| size   | 键值对数量。   | 
| threshold   | size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。   | 
| loadFactor   | 装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。   | 

threshold = capacity * loadFactor，当Size>=threshold的时候，那么就要考虑对数组的扩增了，它是衡量数组是否需要扩增的一个标准。

### 为什么要用红黑树，而不用平衡二叉树？

插入效率比平衡二叉树高，查询效率比普通二叉树高。所以选择性能相对折中的红黑树。

### 为什么在1.8中链表大于8时会转红黑树？

是因为链表的查询速度很慢，引入红黑树可以保证查询速度，至于为什么是8，作者根据概率统计而选择了8作为阀值，桶的长度超过8的概率是非常小的。

### 为什么负载因子是0.75，什么情况下可以调大调小？

负载因子是默认是0.75也是通过实验得来，时间和空间复杂度是最优的。

如果侧重时间复杂度，那么将负载因子调小，如果测试空间复杂度，那么可以将负载因子调大，但一般不建议调整。

### HashMap为什么线程不安全的？

jdk1.8之前，扩容采用的是头插法，头插法在多线程环境下可能会成环，1.8之后采用的是尾插法，不会成环。但1.8之后也不是线程安全的，比如两个线程A和B，同时进行put操作，线程A计算了key的hash值，准备插入，但此时阻塞了，线程B也准备put，计算了key的hash值和A的hash值一样，B进行了put操作，此时A由阻塞态转为运行态，重新赋值，会将线程B的值覆盖掉。

### 如何实现线程安全的hashmap？

1.使用concurrentHashMap

2.hashmap加锁

3.使用CAS的方式

### HashMap 的长度为什么是2的幂次方？

为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。

