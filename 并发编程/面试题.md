### 进程间通讯方法：

1. 管道
2. 消息队列（不是Kafka之类的，是以数据块的方式发送）
3. 共享内存
4. 信号量（互斥的用法类似，a进程访问内存把信号量变0，b进程访问看到0不能访问了）
5. Socket（套接字）
### 线程与协程的区别：

#### 线程：

线程是进程的一个实体，是CPU调度和分派的基本单位，线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

#### 协程：

协程是一种用户态的轻量级线程，协程的调度完全由用户控制。

#### 比较：

1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。

2) 线程进程都是同步机制，而协程则是异步。

3) 协程能保留上一次调用时的状态，避免上下文切换，而且不用加锁。

### 什么是缓存：

	缓存是指可以进行高速数据交换的[存储器](https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8)，它先于内存与CPU交换数据，因此速率很快。

### Linux查看CPU、内存命令：

![图片](https://uploader.shimo.im/f/PO7BqYjjELLUPvnZ.png!thumbnail)

### 查看I/O的命令：

iostat

### Volatile（原子性）:

#### 1、保持内存可见性：

所有线程都能看到共享内存的最新状态。它比Synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。

#### 实现：

如果声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。

#### 各处理器一致性问题：

每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，如果发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效，在处理器对数据进行修改操作时，会重新从系统内存中把数据读到处理器缓存中。

**volatile的特殊规则就是：**

* read、load、use动作必须连续出现。
* assign、store、write动作必须连续出现。

**所以，使用volatile变量能够保证:**

* 每次读取前必须先从主内存刷新最新的值。
* 每次写入后必须立即同步回主内存当中。

Java通过几种原子操作完成工作内存和主内存的交互： 

1. lock：作用于主内存，把变量标识为线程独占状态。
2. unlock：作用于主内存，解除独占状态。
3. read：作用主内存，把一个变量的值从主内存传输到线程的工作内存。
4. load：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中。
5. use：作用工作内存，把工作内存当中的一个变量值传给执行引擎。
6. assign：作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。
7. store：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。
8. write：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中。
#### 2、防止指令重排：

为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。

### 线程生命周期：

新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态。

**1. 新建状态：**

当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值。

**2. 就绪状态：**

当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。

**3. 运行状态：**

如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态。

**4. 阻塞状态：**

当处于运行状态的线程失去所占用资源之后，便进入阻塞状态。

**5. 死亡：**

run()方法执行完成，线程正常结束。

### 死锁：

AB两个线程由于互相持有对方需要的锁，并获取对方的资源，而发生的阻塞现象，我们称为死锁。

#### 死锁的4个重要条件：

1. 互斥条件：一个资源每次只能被一个线程使用。
2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。
4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。
#### 如何避免死锁：

在并发程序中，避免了逻辑中出现多个线程互相持有对方线程所需要的独占锁的的情况，就可以避免死锁。

### sleep()和wait()的区别：

1、sleep是线程中的方法，但是wait是Object中的方法。

2、sleep方法不会释放lock，但是wait会释放，而且会加入到等待队列中。

3、sleep方法不依赖于synchronized，但是wait需要依赖synchronized关键字。

4、sleep不需要被唤醒（休眠之后退出阻塞），但是wait需要（不指定时间需要被别人中断）。



