### redis5种数据结构的实现：

[https://juejin.im/post/5d6bc200f265da03f47c391e#heading-0](https://juejin.im/post/5d6bc200f265da03f47c391e#heading-0)

### Zset实现方式(O(N))：

zset是可排序的set。与hash的实现方式类似，**如果元素个数不多且不大**，就使用压缩列表ziplist来存储。如果过大就使用skiplist跳表来存储。

不过由于zset包含了score的排序信息，所以在ziplist内部，是按照score排序递增来存储的。意味着每次插入数据都要移动之后的数据。

**跳表实现：**[https://juejin.im/post/5e075c9b6fb9a0164c7bbbd7](https://juejin.im/post/5e075c9b6fb9a0164c7bbbd7)

**命令：**ZADD runoobkey 1 redis

### 使用Zset实现延时队列：

#### 扫表：

      对于延时任务，常见的方案就是扫表。扫表就是用一个后台进程，每隔一段时间扫描数 据库的整张数据表，判断每个任务是否达到触发的条件。如果达到条件就执行相应的业务。扫描全表对数据库压力较大，所以一般选择扫从库。扫表的最大优势是实现起来比较简单，而且数据本身存在DB里，因此也不用担心任务数据会丢失，失败的任务可以下次扫描时再重入。但是扫表存在以下问题：  

 

  * 扫表一整张表需要一段时间，会造成任务的触发有延时，有的时候一个进程每个还要扫多个表；
  * 扫表不可能太频繁，因为太频繁会对数据库造成太大压力，每隔一段较长的时间才能再扫一遍，这个时间间隔一般至少在一分钟以上。这也会造成任务延时；
  * 扫表扫的是从库，而主从同步存在延时。特别是当大事务出现时，会导致几分钟甚至几小时的延时；
  * 扫表的方法很笨重，每次扫描一整张表而实际需要触发的任务可能没几个，资源利用很低下；

     扫表最大的问题就是会有延迟，不能再指定的时间里触发，对于时效性高的场景，这种方案是不能满足需求的。

#### Redis的ZSET实现：

     Redis实现延时任务，是通过其数据结构ZSET来实现的。ZSET会储存一个score和一个value，可以将value按照score进行排序，而SET是无序的。    

 

延时任务的实现分为以下几步来实现：

 (1) 将任务的执行时间作为score，要执行的任务数据作为value，存放在zset中；

 (2) 用一个进程定时查询zset的score分数最小的元素，可以用ZRANGEBYSCORE key -inf +inf limit 0 1 withscores命令来实现;

 (3) 如果最小的分数小于等于当前时间戳，就将该任务取出来执行，否则休眠一段时间后再查询

      redis的ZSET是通过跳跃表来实现的，复杂度为O(logN)，N是存放在ZSET中元素的个数。用redis来实现可以依赖于redis自身的持久化来实现持久化机制，redis的集群来支持高并发和高可用。因此开发成本很小，可以做到很实时。

### 字典（哈希键，O(N)）：

字典中每一个键都是独一无二的，是一种用于保存键值对的抽象数据结构。

#### 哈希算法：

当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引里面。

#### 解决键冲突（头插法）：

当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突。

Redis的哈希表使用链地址法来解决键冲突，每个哈希表节点都有个一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决乐键冲突的问题。

#### 渐进式rehash：

当哈希表保存的键值对数量太多或者太小时，程序需要对哈希表的大小进行相应的扩展或者收缩。

当有新数据要插入时，将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次一次性数据搬移，插入操作就都变得很快了。这个过程也被称为**渐进式rehash**。

### redis数据结构的使用场景：

#### String类型

是二进制安全的，可以用来缓存一些静态文件，如图片、视频、css文件等。

#### list

微博中“关注、粉丝”、论坛中所有回帖的ID用的就是list列表，还有消息队列，也是列表。

**Set**

可以快速查找元素是否存在，用于记录一些不能重复的数据。例如： 在网站注册账号时，用户名不能重复，使用Set记录注册用户，如果注册的用户名已经存在于Set中，就拒绝该用户注册。或者用于记录做过某些事情。例如： 在某些投票系统中，每个用户一天只能投票一次，就可以用Set来记录某个用户的投票情况。

**Sorted Set**

使用Sorted Set构建一个具有优先级的队列。

**Hash**

适用于存储对象，比如把用户的信息存到hash里，以用户id为key，用户的详细信息为value。



