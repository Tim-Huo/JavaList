### redis key 的过期策略？

我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。

#### 过期策略通常有以下三种：

* 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。

该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。

 

* 惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。

该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。

 

* 定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。

该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。
 (expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)

**Redis中同时使用了惰性过期和定期过期两种过期策略。**

### Redis如何实现高并发（主从架构【参考主从复制】、读写分离）：

Redis架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。

### **Redis****为什么这么快？**

1. Redis将数据存储到内存中，避免了I/O操作的限制。
2. 采用单线程的当时，避免了不必要的上下文切换和竞争条件；而且不用考虑锁的问题，带来的消耗。
3. 使用多路I/O复用模型，非阻塞IO

注：这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程（尽量减少网络 IO 的时间消耗）。

### Redis单线程的弊端：

1. 无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善。
### 缓存穿透：

那么请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去，会导致你的数据库由于压力过大而宕掉。这种查询不存在数据的现象我们称为**缓存穿透**。

**解决：**

  1. 我们就可以为这些key对应的值设置为null 丢到缓存里面去。后面再出现查询这个key 的请求的时候，直接返回null 。
  2. 在缓存之前在加一层 BloomFilter（布隆过滤器） ，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 -> 查 DB。
### 缓存击穿：

在平常高并发的系统中，大量的请求同时查询一个 key 时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们称为**缓存击穿**。会造成某一时刻数据库请求量过大，压力剧增。

**解决：**

我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。

### 缓存雪崩：

缓存雪崩的情况是说，当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上面。结果就是DB 称不住，挂掉。

**解决：**

使用集群缓存，保证缓存服务的高可用。

### 数据库双写一致性：

#### 先更新数据库，再删缓存

问题：比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。

**方案一**：

![图片](https://uploader.shimo.im/f/pW65NAzE4WpY8PxE.png!thumbnail)

流程如下所示

（1）更新数据库数据；

（2）缓存因为种种问题删除失败

（3）将需要删除的key发送至消息队列

（4）自己消费消息，获得需要删除的key

（5）继续重试删除操作，直到成功

