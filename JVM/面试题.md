### JMM内存模型：

java内存模型是**共享内存的并发模型**，线程之间主要通过读-写共享变量来完成隐式通信。

JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。

[https://juejin.im/post/5dbfa0aa51882538ce1a4ebc](https://juejin.im/post/5dbfa0aa51882538ce1a4ebc)

### Java类加载进机制：

Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。

#### 类加载的过程：

加载、验证、准备、解析、初始化。

![图片](https://uploader.shimo.im/f/beTOqwcsTNzD4ns0.png!thumbnail)

**加载：**查找和导入Class文件；

**验证：**检查载入Class文件数据的正确性；

**准备：**给类的静态变量分配存储空间；

**解析：**将符号引用转成直接引用；

**初始化：**对类的静态变量，静态代码块执行初始化操作。

#### **类与类加载器：**

对于任何一个类，都需要由加载它的类加载器和这个类来确立其在JVM中的唯一性。也就是说，两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等。

#### 三种类加载器：

1、启动类加载器：

负责加载JAVA_HOME\lib目录中并且能被虚拟机识别的类库到JVM内存中。

2、扩展类加载器：

该加载器主要是负责加载JAVA_HOME\lib\，该加载器可以被开发者直接使用。

3、应用程序类加载器：

该类加载器也称为系统类加载器，它负责加载用户类路径（Classpath）上所指定的类库。

#### 双亲委派模型：

双亲委派模型的工作过程为：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。


![图片](https://uploader.shimo.im/f/2IfnuX094wyMtO4s.png!thumbnail)

### 为什么区分老年代新生代？

新生代和老年代是针对于分代收集算法来定义的。

