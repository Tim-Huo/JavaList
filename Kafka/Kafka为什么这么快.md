### 系统缓存+顺序写

Kafka生产者将消息写入各个broker中的时候，并不会直接写入磁盘，在这中间有一些缓存，被称为Page Cache，它是基于操作系统的缓存，因为也被称为OS Cache，数据写入的时候，会将数据写入缓存，然后由操作系统决定什么时候写入磁盘，可以看到，写入数据时是直接和内存交互，因此其写入性能很高，当然不仅仅如此，在从缓存写入磁盘的时候，它会将随机写优化为顺序写，我们都知道，磁盘的写入是基于磁道寻址的，随机写会引发大量的磁盘寻址，浪费大量的时间，而顺序写避免了频繁的寻址操作，写入性能提高了数倍。

![图片](https://uploader.shimo.im/f/0NUQxLXmVhbMwH1D.png!thumbnail)

### 零拷贝技术

所谓零拷贝技术就是避免操作系统内核态到用户态的切换，直接基于内核，避免了不必要的上下文切换与拷贝，大大的提高了性能。

![图片](https://uploader.shimo.im/f/f2uYN7DNUMTH83gr.png!thumbnail)

### 可靠性

acks 参数指定了要有多少个分区副本接收消息，生产者才认为消息是写入成功的。此参数对消息丢失的影响较大

 

* 如果 acks = 0，就表示生产者也不知道自己产生的消息是否被服务器接收了，它才知道它写成功了。如果发送的途中产生了错误，生产者也不知道，它也比较懵逼，因为没有返回任何消息。这就类似于 UDP 的运输层协议，只管发，服务器接受不接受它也不关心。
* 如果 acks = 1，这种方式表示生产者需要等待接收主节点的应答消息才会知道数据写入成功，如果没有收到应答信息或者当前集群因为选举没有主节点，此时会抛出异常。但是如果一台节点没有收到消息成为了主节点，此时会数据还是会丢失。
* 如果 acks = all，这种情况下是只有当所有参与复制的节点都收到消息时，生产者才会接收到一个来自服务器的消息。不过，它的延迟比 acks =1 时更高，因为我们要等待不只一个服务器节点接收消息。

 

