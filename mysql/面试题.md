### 什么情况下数据库索引会失效?

1、在where字句中进行null值判断。

2、避免在where字句中使用!=,<>这样的符号。因为这种符号会遍历全表。

3、避免在where子句中使用or来连接条件,因为如果俩个字段中有一个没有索引的话,引擎会放弃索引而产生全表扫描。

4、避免在where子句中=的左边使用表达式操作或者函数操作。

5、避免在where子句中使用like模糊查询

### B+树：

B+树是一种平衡查找树，在B+树中，所有数据都是放在叶子节点当中，并且是有顺序的，各叶节点指针进行连接。

### innodb 与myisam 的区别？

#### InnoDB：

①InnoDB 支持事务。

②支持外键。

③支持行级锁（默认）。

④InnoDB是聚簇索引，聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。

⑤InnoDB 最小的锁粒度是行锁。

####       MyISAM：

①MyISAM 不支持事务。

②MyISAM 是非聚集索引。数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

③MyISAM 最小的锁粒度是表锁。个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。

### innodb 与myisam如何选择：

  1. 是否要支持事务，如果要请选择 InnoDB，如果不需要可以考虑 MyISAM；
  2. 如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使用InnoDB。
  3. 系统奔溃后，MyISAM恢复起来更困难，能否接受，不能接受就选 InnoDB；
### 聚簇索引：

叶子节点存在主键，根据主键直接查找到值。

### 非聚簇索引：

非叶子节点中存的是物理地址，数据存在另一张表里。

①先根据普通索引列遍历B+树，取出主键值。

②根据主键值去主键B+树查找到整行数据（相当于查找两遍B+树）。

### 行级锁（两种）：

行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。

####       共享锁：

共享锁又称读锁，用户可以并发读取数据。

####       排他锁：

排他锁又称写锁，某个事物获得锁，其它事务无法进行操作。获准排他锁的事务既能读数据，又能修改数据。

### 表级锁：

表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁。

### 索引下推：

存储引擎层过滤完数据后，一同返回给服务层，减少IO操作。

根据条件查出全部索引后，一同去查询数据行，减少回表操作。

**以前操作：**先查第一个条件的索引，然后回表查询出数据，在查第二个条件的索引，再去查询数据，回表操作太多。

### mysql日志系统之redo log和bin log：

#### redo log：

在同一个事务中，每当数据库进行修改数据操作时，将修改结果更新到内存后，会在redo log添加一行记录记录“需要在哪个数据页上做什么修改”，并将该记录状态置为prepare，等到commit提交事务后，会将此次事务中在redo log添加的记录的状态都置为commit状态，之后将修改落盘时，会将redo log中状态为commit的记录的修改都写入磁盘。过程如下图

![图片](https://uploader.shimo.im/f/Fey5SOTpOLDf7URx.png!thumbnail)

**问题：**

1、redo log的大小是固定的，日志上的记录修改落盘后，日志会被覆盖掉，无法用于数据回滚/数据恢复等操作。

2、redo log是innodb引擎层实现的，并不是所有引擎都有。

#### binlog：

  1. binlog是server层实现的，意味着所有引擎都可以使用binlog日志。
  2. binlog有两种记录模式，**statement格式**的话是记sql语句， **row格式**会记录行的内容，记两条，更新前和更新后都有。

binlog和redo log必须保持一致，不允许出现binlog有记录但redolog没有的情况，反之亦然。之前说过在一个事务中，redolog有prepare和commit两种状态，所以，在redolog状态为prepare时记录binlog可保证两日志的记录一致，下图列出各种情况来说明。 

![图片](https://uploader.shimo.im/f/qZI9jFjCtYLr3yMv.png!thumbnail)


### 如何避免sql注入：

1. 避免将用户提供的输入直接放入SQL语句中；最好使用准备好的语句和参数化查询，这样更安全。
2. 避免直接向用户显示数据库错误，攻击者可以使用这些错误消息来获取有关数据库的信息。
### 索引是建立得越多越好吗？

1. 数据量小的表不需要建立索引,建立会增加额外的索引开销；
2. 数据变更需要维护索引,因此更多的索引意味着更多的维护成本；
### 什么样的字段适合建索引？

1、表的主键、外键必须有索引； 

2、数据量超过300的表应该有索引；

3、经常与其他表进行连接的表，在连接字段上应该建立索引； 

### 间隙锁（RR可重复读隔离级别下）：

间隙锁是封锁索引记录中的间隔。


